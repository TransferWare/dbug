<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>dbug - C Program Debugging Package</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@4dgh7.p1s.plx.sd.apple.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Debugging-using-print-statements">Debugging using print statements</a></li>
      <li><a href="#Debug-disable-techniques">Debug disable techniques</a></li>
      <li><a href="#More-readable-preprocessor-usage">More readable preprocessor usage</a></li>
    </ul>
  </li>
  <li><a href="#OPTIONS">OPTIONS</a>
    <ul>
      <li><a href="#Debug-macros">Debug macro&#39;s</a></li>
      <li><a href="#Debug-functions">Debug functions</a></li>
      <li><a href="#Debug-arguments">Debug arguments</a></li>
      <li><a href="#Type-definitions">Type definitions</a></li>
      <li><a href="#Debug-control-string">Debug control string</a></li>
      <li><a href="#Debugging-output">Debugging output</a></li>
      <li><a href="#Debug-reporting-tool">Debug reporting tool</a></li>
      <li><a href="#Debug-report-options">Debug report options</a></li>
    </ul>
  </li>
  <li><a href="#EXAMPLES">EXAMPLES</a>
    <ul>
      <li><a href="#Main-function-for-factorial-program">Main function for factorial program</a></li>
      <li><a href="#Factorial-function">Factorial function</a></li>
      <li><a href="#No-debugging-and-or-tracing">No debugging and/or tracing</a></li>
      <li><a href="#Function-level-tracing">Function level tracing</a></li>
      <li><a href="#Function-level-tracing-and-debugging">Function level tracing and debugging</a></li>
      <li><a href="#Debugging-a-break-point">Debugging a break point</a></li>
      <li><a href="#Debugging-a-function">Debugging a function</a></li>
      <li><a href="#Profiling-a-program">Profiling a program</a></li>
    </ul>
  </li>
  <li><a href="#NOTES">NOTES</a>
    <ul>
      <li><a href="#Tips">Tips</a></li>
      <li><a href="#Compatibility">Compatibility</a></li>
    </ul>
  </li>
  <li><a href="#CAVEATS">CAVEATS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#HISTORY">HISTORY</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>dbug - C Program Debugging Package</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>cc [ <b>flag</b> ... ] <b>file</b> ... -ldbug [ <b>library</b> ... ]</p>

<p>#include &lt;dbug.h&gt;</p>

<p>dbug_errno_t dbug_init_ctx( const char * <code>options</code>, const char *<code>name</code>, dbug_ctx_t* <code>dbug_ctx</code> );</p>

<p>dbug_errno_t dbug_init( const char * <code>options</code>, const char *<code>name</code> );</p>

<p>dbug_errno_t dbug_push( const char * <code>options</code> );</p>

<p>dbug_errno_t dbug_done_ctx( dbug_ctx_t* <code>dbug_ctx</code> );</p>

<p>dbug_errno_t dbug_done( void );</p>

<p>dbug_errno_t dbug_enter_ctx( const dbug_ctx_t <code>dbug_ctx</code>, const char *<code>file</code>, const char *<code>function</code>, const int <code>line</code>, int *<code>dbug_level</code> );</p>

<p>dbug_errno_t dbug_enter( const char *<code>file</code>, const char *<code>function</code>, const int <code>line</code>, int *<code>dbug_level</code> );</p>

<p>dbug_errno_t dbug_leave_ctx( const dbug_ctx_t <code>dbug_ctx</code>, const int <code>line</code>, int *<code>dbug_level</code> );</p>

<p>dbug_errno_t dbug_leave( const int <code>line</code>, int *<code>dbug_level</code> );</p>

<p>dbug_errno_t dbug_print_ctx( const dbug_ctx_t <code>dbug_ctx</code>, const int <code>line</code>, const char *<code>break_point</code>, const char *<code>format</code>, /* <code>fields</code> */ ... );</p>

<p>dbug_errno_t dbug_print( const int <code>line</code>, const char *<code>break_point</code>, const char *<code>format</code>, /* <code>fields</code> */ ... );</p>

<p>dbug_errno_t dbug_print_start_ctx( const dbug_ctx_t <code>dbug_ctx</code>, const int <code>line</code>, const char *<code>break_point</code> );</p>

<p>dbug_errno_t dbug_print_start( const int <code>line</code>, const char *<code>break_point</code> );</p>

<p>dbug_errno_t dbug_print_end( const char *<code>format</code>, /* <code>fields</code> */ ... );</p>

<p>dbug_errno_t dbug_dump_ctx( const dbug_ctx_t <code>dbug_ctx</code>, const int <code>line</code>, const char *<code>break_point</code>, const void *<code>memory</code>, const unsigned int <code>len</code> );</p>

<p>dbug_errno_t dbug_dump( const int <code>line</code>, const char *<code>break_point</code>, const void *<code>memory</code>, const unsigned int <code>len</code> );</p>

<p>void DBUG_INIT_CTX( const char * <code>options</code>, const char *<code>name</code>, dbug_ctx_t* <code>dbug_ctx</code> );</p>

<p>void DBUG_INIT( const char * <code>options</code>, const char *<code>name</code> );</p>

<p>void DBUG_PUSH( const char * <code>options</code> );</p>

<p>void DBUG_DONE_CTX( dbug_ctx_t* <code>dbug_ctx</code> );</p>

<p>void DBUG_DONE( void );</p>

<p>void DBUG_POP( void );</p>

<p>void DBUG_ENTER_CTX( const dbug_ctx_t <code>dbug_ctx</code>, const char *<code>function</code> );</p>

<p>void DBUG_ENTER( const char *<code>function</code> );</p>

<p>void DBUG_LEAVE_CTX( const dbug_ctx_t <code>dbug_ctx</code> );</p>

<p>void DBUG_LEAVE( void );</p>

<p>void DBUG_PRINT_CTX( const dbug_ctx_t <code>dbug_ctx</code>, const char *<code>break_point</code>, ( const char *<code>format</code>, /* <code>fields</code> */ ... ) );</p>

<p>void DBUG_PRINT( const char *<code>break_point</code>, ( const char *<code>format</code>, /* <code>fields</code> */ ... ) );</p>

<p>void DBUG_DUMP_CTX( const dbug_ctx_t <code>dbug_ctx</code>, const char *<code>break_point</code>, const void *<code>memory</code>, const unsigned int <code>len</code> );</p>

<p>void DBUG_DUMP( const char *<code>break_point</code>, const void *<code>memory</code>, const unsigned int <code>len</code> );</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This documentation describes <i>dbug</i>, a macro based C debugging package which has proven to be a very flexible and useful tool for debugging, testing, and porting C programs.</p>

<p>All of the features of the <i>dbug</i> package can be enabled or disabled dynamically at execution time. This means that production programs will run normally when debugging is not enabled, and eliminates the need to maintain two separate versions of a program.</p>

<p>Many of the things easily accomplished with conventional debugging tools, such as symbolic debuggers, are difficult or impossible with this package, and vice versa. Thus the <i>dbug</i> package should <i>not</i> be thought of as a replacement or substitute for other debugging tools, but simply as a useful <i>addition</i> to the program development and maintenance environment.</p>

<p>Almost every program development environment worthy of the name provides some sort of debugging facility. Usually this takes the form of a program which is capable of controlling execution of other programs and examining the internal state of other executing programs. These types of programs will be referred to as external debuggers since the debugger is not part of the executing program. Examples of this type of debugger include the <b>adb</b> and <b>sdb</b> debuggers provided with the <b>UNIX</b> operating system.</p>

<p>One of the problems associated with developing programs in an environment with good external debuggers is that developed programs tend to have little or no internal instrumentation. This is usually not a problem for the developer since he is, or at least should be, intimately familiar with the internal organization, data structures, and control flow of the program being debugged. It is a serious problem for maintenance programmers, who are unlikely to have such familiarity with the program being maintained, modified, or ported to another environment. It is also a problem, even for the developer, when the program is moved to an environment with a primitive or unfamiliar debugger, or even no debugger.</p>

<p>On the other hand, <i>dbug</i> is an example of an internal debugger. Because it requires internal instrumentation of a program, and its usage does not depend on any special capabilities of the execution environment, it is always available and will execute in any environment that the program itself will execute in. In addition, since it is a complete package with a specific user interface, all programs which use it will be provided with similar debugging capabilities.</p>

<p>This is in sharp contrast to other forms of internal instrumentation where each developer has their own, usually less capable, form of internal debugger. In summary, because <i>dbug</i> is an internal debugger it provides consistency across operating environments, and because it is available to all developers it provides consistency across all programs in the same environment.</p>

<p>The <i>dbug</i> package imposes only a slight speed penalty on executing programs, typically much less than 10 percent, and a modest size penalty, typically 10 to 20 percent. By defining a specific C preprocessor symbol both of these can be reduced to zero with no changes required to the source code.</p>

<p>The following list is a quick summary of the capabilities of the <i>dbug</i> package. Each capability can be individually enabled or disabled at the time a program is invoked by specifying the appropriate command line arguments.</p>

<ul>

<li><p>Execution trace showing function level control flow in a semi-graphically manner using indentation to indicate nesting depth.</p>

</li>
<li><p>Output the values of all, or any subset of, key internal variables.</p>

</li>
<li><p>Limit actions to a specific set of named functions.</p>

</li>
<li><p>Label each output line with source file name and line number.</p>

</li>
<li><p>Label each output line with name of current process.</p>

</li>
<li><p>Use several debugging contexts to support multi-threaded programs.</p>

</li>
<li><p>Redirect the debug output stream to standard output (stdout), standard error (stderr) or a named file. The default output stream is standard output (stdout). The redirection mechanism is completely independent of normal command line redirection to avoid output conflicts.</p>

</li>
<li><p>Enable profiling of the program being debugged as well as stack usage.</p>

</li>
</ul>

<h2 id="Debugging-using-print-statements">Debugging using print statements</h2>

<p>Internal instrumentation is already a familiar concept to most programmers, since it is usually the first debugging technique learned. Typically, &quot;print statements&quot; are inserted in the source code at interesting points, the code is recompiled and executed, and the resulting output is examined in an attempt to determine where the problem is.</p>

<p>The procedure is iterative, with each iteration yielding more and more output, and hopefully the source of the problem is discovered before the output becomes too large to deal with or previously inserted statements need to be removed. Figure 1 is an example of this type of primitive debugging technique.</p>

<pre><code>  #include &lt;stdio.h&gt;

  int main (int argc, char **argv)
  {
      printf (&quot;argv[0] = %d\n&quot;, argv[0]);
      /*
       *  Rest of program
       */
      printf (&quot;== done ==\n&quot;);
  }

  Figure 1
  Primitive Debugging Technique</code></pre>

<p>Eventually, and usually after at least several iterations, the problem will be found and corrected. At this point, the newly inserted print statements must be dealt with. One obvious solution is to simply delete them all.</p>

<h2 id="Debug-disable-techniques">Debug disable techniques</h2>

<p>Beginners usually do this a few times until they have to repeat the entire process every time a new bug pops up. The second most obvious solution is to somehow disable the output, either through the source code comment facility, creation of a debug variable to be switched on or off, or by using the C preprocessor. Figure 2 is an example of all three techniques.</p>

<pre><code>  #include &lt;stdio.h&gt;

  int debug = 0;

  int main (int argc, char **argv)
  {
      /* printf (&quot;argv = %x\n&quot;, argv) */
      if (debug) printf (&quot;argv[0] = %d\n&quot;, argv[0]);
      /*
       *  Rest of program
       */
  #ifdef DEBUG
      printf (&quot;== done ==\n&quot;);
  #endif
  }
      
  Figure 2
  Debug Disable Techniques</code></pre>

<p>Each technique has its advantages and disadvantages with respect to dynamic vs static activation, source code overhead, recompilation requirements, ease of use, program readability, etc. Overuse of the preprocessor solution quickly leads to problems with source code readability and maintainability when multiple <b>#ifdef</b> symbols are to be defined or undefined based on specific types of debug desired.</p>

<p>The source code can be made slightly more readable by suitable indentation of the <b>#ifdef</b> arguments to match the indentation of the code, but not all C preprocessors allow this.</p>

<h2 id="More-readable-preprocessor-usage">More readable preprocessor usage</h2>

<p>The only requirement for the standard <b>UNIX</b> C preprocessor is for the &#39;#&#39; character to appear in the first column, but even this seems like an arbitrary and unreasonable restriction. Figure 3 is an example of this usage.</p>

<pre><code>  #include &lt;stdio.h&gt;

  int main (int argc, char **argv)
  {
  #   ifdef DEBUG
      printf (&quot;argv[0] = %d\n&quot;, argv[0]);
  #   endif
      /*
       *  Rest of program
       */
  #   ifdef DEBUG
      printf (&quot;== done ==\n&quot;);
  #   endif
  }

  Figure 3
  More Readable Preprocessor Usage</code></pre>

<h1 id="OPTIONS">OPTIONS</h1>

<h2 id="Debug-macros">Debug macro&#39;s</h2>

<p>This section summarizes the usage of all currently defined macros in the <i>dbug</i> package. These macro&#39;s can be used in C programs. The macros definitions are found in the user include file <b>dbug.h</b>.</p>

<dl>

<dt id="DBUG_OFF">DBUG_OFF</dt>
<dd>

<p>This macro disables compilation of all other <i>dbug</i> macro&#39;s. This will result in null macros expansions so that the resulting code will be smaller and faster. (The difference may be smaller than you think so this step is recommended only when absolutely necessary). In general, tradeoffs between space and efficiency are decided in favor of efficiency since space is seldom a problem on the new machines). By default this macro is disabled.</p>

<p>EX: #define DBUG_OFF</p>

</dd>
<dt id="DBUG_INIT-and-DBUG_INIT_CTX">DBUG_INIT and DBUG_INIT_CTX</dt>
<dd>

<p>Initializes a debugger context using the debug control string passed as the macro argument. The name supplied may be NULL. In that case a name for the debugging context is generated. DBUG_INIT uses an internal debugging context. In a multi-threaded environment (POSIX threads), thread specific data is used for DBUG_INIT.</p>

<p>EX: DBUG_INIT (&quot;Odbug.log,d,t&quot;, NULL);</p>

<p>EX: dbug_ctx_t dbug_ctx; DBUG_INIT_CTX (&quot;d,t&quot;, NULL, &amp;dbug_ctx);</p>

<p>EX: DBUG_INIT (&quot;&quot;, &quot;Process DBUG&quot;);</p>

</dd>
<dt id="DBUG_PUSH">DBUG_PUSH</dt>
<dd>

<p>This macro converts the <i>options</i> parameter from the old format to the new format and then calls DBUG_INIT.</p>

<p>EX: DBUG_PUSH (&quot;O,dbug.log:d:t&quot;);</p>

</dd>
<dt id="DBUG_DONE-and-DBUG_DONE_CTX">DBUG_DONE and DBUG_DONE_CTX</dt>
<dd>

<p>Destroys the debugging context as initialized by DBUG_INIT. The DBUG_DONE macro has no arguments. The DBUG_DONE_CTX has the debugging context as parameter.</p>

<p>EX: DBUG_DONE ();</p>

<p>EX: dbug_ctx_t dbug_ctx; DBUG_DONE_CTX (&amp;dbug_ctx);</p>

</dd>
<dt id="DBUG_POP">DBUG_POP</dt>
<dd>

<p>Is the same as <code>DBUG_DONE</code>.</p>

</dd>
<dt id="DBUG_ENTER-and-DBUG_ENTER_CTX">DBUG_ENTER and DBUG_ENTER_CTX</dt>
<dd>

<p>Used to tell the run-time support module the name of the function being entered. The DBUG_ENTER must be supplied the name of the function entered. The DBUG_INIT_CTX needs a debugging context. The DBUG_ENTER macro must precede all executable lines in the function just entered, and must come after all local declarations. Each DBUG_ENTER macro must have a matching DBUG_LEAVE macro at the function exit points. DBUG_ENTER macros used without a matching DBUG_LEAVE macro will cause warning messages from the <i>dbug</i> package run-time support module.</p>

<p>Before a DBUG_ENTER call can be executed, the (internal) debugging context must have been initialized via <code>DBUG_INIT</code>.</p>

<p>EX: DBUG_ENTER (&quot;main&quot;);</p>

<p>EX: dbug_ctx_t dbug_ctx; DBUG_ENTER_CTX (dbug_ctx, &quot;main&quot;);</p>

</dd>
<dt id="DBUG_LEAVE-and-DBUG_LEAVE_CTX">DBUG_LEAVE and DBUG_LEAVE_CTX</dt>
<dd>

<p>Used at each exit point of a function containing a DBUG_ENTER macro at the entry point. It is an error to have a DBUG_LEAVE macro in a function which has no matching DBUG_ENTER macro, and the compiler will complain if the macros are actually used (expanded).</p>

<p>EX: DBUG_LEAVE();</p>

<p>EX: dbug_ctx_t dbug_ctx; DBUG_LEAVE_CTX(dbug_ctx);</p>

</dd>
<dt id="DBUG_PRINT-and-DBUG_PRINT_CTX">DBUG_PRINT and DBUG_PRINT_CTX</dt>
<dd>

<p>Used to do printing via the &quot;fprintf&quot; library function on the current debug stream. The input arguments are a break point, a format string and the corresponding argument list. Note that the format and following parameters are all one macro argument and <b>must</b> be enclosed in parenthesis. The DBUG_PRINT_CTX has one extra input parameter: the debugging context. When the DBUG_PRINT statement is called within a pair of DBUG_ENTER/DBUG_LEAVE statements, the function context is also printed, otherwise that is empty.</p>

<p>EX: DBUG_PRINT (&quot;type&quot;, (&quot;type is %x&quot;, type));</p>

<p>EX: dbug_ctx_t dbug_ctx; DBUG_PRINT_CTX (dbug_ctx, &quot;stp&quot;, (&quot;%x -&gt; %s&quot;, stp, stp -&gt; name));</p>

</dd>
<dt id="DBUG_DUMP-and-DBUG_DUMP_CTX">DBUG_DUMP and DBUG_DUMP_CTX</dt>
<dd>

<p>Used to do dump a piece of memory via the &quot;fprintf&quot; library function on the current debug stream. The input arguments are a break point, a memory address and the number of bytes to print. The DBUG_DUMP_CTX has one extra input parameter: the debugging context. Before a DBUG_DUMP statement can be executed a DBUG_ENTER statement must have been executed, i.e. DBUG_DUMP needs a function context.</p>

<p>EX: char buf[] = &quot;abcde&quot;; DBUG_DUMP(&quot;type&quot;, buf, strlen(buf) );</p>

</dd>
<dt id="DBUG_EXECUTE-break_point-a1">DBUG_EXECUTE(break_point, a1)</dt>
<dd>

<p>This macro is preserved for backwards compatibility. It does nothing.</p>

</dd>
<dt id="DBUG_PROCESS-a1">DBUG_PROCESS(a1)</dt>
<dd>

<p>This macro has been used to supply the process name for the debugging context. Use <code>DBUG_INIT</code> to specify the name.</p>

</dd>
<dt id="DBUG_FILE">DBUG_FILE</dt>
<dd>

<p>Same as stderr. This macro is preserved for backwards compatibility.</p>

</dd>
<dt id="DBUG_RETURN-a1">DBUG_RETURN(a1)</dt>
<dd>

<p>Performs a <code>DBUG_LEAVE</code> and returns parameter <i>a1</i>. This macro is preserved for backwards compatibility.</p>

</dd>
<dt id="DBUG_VOID_RETURN">DBUG_VOID_RETURN</dt>
<dd>

<p>Performs a <code>DBUG_LEAVE</code> and returns. This macro is preserved for backwards compatibility.</p>

</dd>
</dl>

<h2 id="Debug-functions">Debug functions</h2>

<p>This section summarizes the usage of all currently defined functions in the <i>dbug</i> package. The main purpose of these functions is to invoke them from external programs written in another language, such as Perl. The functions are found in the user include file <b>dbug.h</b>.</p>

<dl>

<dt id="dbug_init_ctx-and-dbug_init">dbug_init_ctx and dbug_init</dt>
<dd>

<p>See <code>DBUG_INIT</code>.</p>

</dd>
<dt id="dbug_push">dbug_push</dt>
<dd>

<p>See <code>DBUG_PUSH</code>.</p>

</dd>
<dt id="dbug_done_ctx-and-dbug_done">dbug_done_ctx and dbug_done</dt>
<dd>

<p>See <code>DBUG_DONE</code>.</p>

</dd>
<dt id="dbug_enter_ctx-and-dbug_enter">dbug_enter_ctx and dbug_enter</dt>
<dd>

<p>Used to tell the run-time support module the name of the function being entered, the name of the file, the line number and a nesting level. The nesting level is also used for determining how much stack space is used. See also <code>DBUG_ENTER</code>.</p>

<p>EX: dbug_enter( __FILE__, &quot;main&quot;, __LINE__, &amp;dbug_level );</p>

<p>EX: dbug_enter_ctx( dbug_ctx, __FILE__, &quot;main&quot;, __LINE__, &amp;dbug_level );</p>

</dd>
<dt id="dbug_leave_ctx-and-dbug_leave">dbug_leave_ctx and dbug_leave</dt>
<dd>

<p>Used at each exit point of a function containing a dbug_enter or dbug_enter_ctx function at the entry point. Input parameters are the line number and the nesting level set at the start of the function must also be supplied to enable checking balanced dbug_enter/dbug_leave calls. See also <code>DBUG_LEAVE</code>.</p>

<p>EX: dbug_leave( __LINE__, &amp;dbug_level );</p>

<p>EX: dbug_leave_ctx( dbug_ctx, __LINE__, &amp;dbug_level );</p>

</dd>
<dt id="dbug_print_ctx-and-dbug_print">dbug_print_ctx and dbug_print</dt>
<dd>

<p>Print a formatted string with variable arguments. See also <code>DBUG_PRINT</code>.</p>

<p>EX: dbug_print( 1, &quot;info&quot;, &quot;This is %s and that is %s&quot;, &quot;this&quot;, &quot;that&quot; );</p>

<p>EX: dbug_print_ctx( dbug_ctx, 1, &quot;info&quot;, &quot;This is %s and that is %s&quot;, &quot;this&quot;, &quot;that&quot; );</p>

</dd>
<dt id="dbug_print_start_ctx-and-dbug_print_start">dbug_print_start_ctx and dbug_print_start</dt>
<dd>

<p>Used for saving print info which is used in <code>dbug_print_end</code>. Is used in <code>DBUG_PRINT</code>. Should not be used directly.</p>

</dd>
<dt id="dbug_print_end">dbug_print_end</dt>
<dd>

<p>Print a formatted string with variable arguments. A call to dbug_print_start (or dbug_print_start_ctx) must have preceded a call to dbug_print_end. See also <code>DBUG_PRINT</code>. Should not be used directly.</p>

</dd>
<dt id="dbug_dump-and-dbug_dump_ctx">dbug_dump and dbug_dump_ctx</dt>
<dd>

<p>See <code>DBUG_DUMP</code>.</p>

</dd>
</dl>

<h2 id="Debug-arguments">Debug arguments</h2>

<dl>

<dt id="break_point">break_point</dt>
<dd>

<p>The break point for a line of output. Can be used by the reporting tool to display only lines which have this break point.</p>

</dd>
<dt id="dbug_ctx">dbug_ctx</dt>
<dd>

<p>A debugging context. Must be treated as an opaque type. See also <code>dbug_ctx_t</code>.</p>

</dd>
<dt id="dbug_level">dbug_level</dt>
<dd>

<p>An optional check for matching dbug_enter() and dbug_leave() (and their variants) calls.</p>

</dd>
<dt id="fields">fields</dt>
<dd>

<p>A variable argument list.</p>

</dd>
<dt id="file">file</dt>
<dd>

<p>The source file where the call is performed. The __FILE__ preprocessor constant is recommended.</p>

</dd>
<dt id="format">format</dt>
<dd>

<p>A printf format.</p>

</dd>
<dt id="function">function</dt>
<dd>

<p>The name of the function which is entered.</p>

</dd>
<dt id="len">len</dt>
<dd>

<p>The number of bytes to dump for a piece of <code>memory</code>.</p>

</dd>
<dt id="line">line</dt>
<dd>

<p>The source line where the call is performed. The __LINE__ preprocessor constant is recommended.</p>

</dd>
<dt id="memory">memory</dt>
<dd>

<p>The memory to dump.</p>

</dd>
<dt id="name">name</dt>
<dd>

<p>The name of the debug thread. It may be NULL which means the <i>DBUG</i> library will generate a name.</p>

</dd>
<dt id="options">options</dt>
<dd>

<p>The debug control string which will be described later in detail. If the options string is NULL the first ever options string will be used. Thus it is possible to supply the options string only once and use this string for other threads which may not have access to the first options string (for instance a command line parameter).</p>

</dd>
</dl>

<h2 id="Type-definitions">Type definitions</h2>

<dl>

<dt id="dbug_ctx_t">dbug_ctx_t</dt>
<dd>

<pre><code>      typedef void * dbug_ctx_t;</code></pre>

</dd>
<dt id="dbug_errno_t">dbug_errno_t</dt>
<dd>

<pre><code>      typedef int dbug_errno_t;</code></pre>

</dd>
</dl>

<h2 id="Debug-control-string">Debug control string</h2>

<p>The debug control string is used to set the state of the debugger via the <code>DBUG_INIT</code> macro. This section summarizes the currently available debugger options and the flag characters which enable or disable them. Arguments are enclosed in &#39;&lt;&#39; and &#39;&gt;&#39;. Arguments which are also enclosed in &#39;[&#39; and &#39;]&#39; are optional. The options in the debug control string are separated by the comma (,) or semi-colon (;) and may not have spaces. The argument of an option follows the option and is separated by an equal sign (=).</p>

<dl>

<dt id="d">d</dt>
<dd>

<p>Enable output from DBUG_PRINT macros.</p>

</dd>
<dt id="D-time">D=&lt;time&gt;</dt>
<dd>

<p>Delay for specified time after each output line, to let output drain. Time is given in milliseconds (a value of 1000 is one second). Default is zero. Either tracing or debugging (options t or d) must be enabled.</p>

</dd>
<dt id="g">g</dt>
<dd>

<p>Turn on machine independent profiling. Timing results are collected and sent to output.</p>

</dd>
<dt id="o-file">o[=&lt;file&gt;]</dt>
<dd>

<p>Redirect the debugger output stream to the specified file. A null argument causes output to be redirected to stderr.</p>

</dd>
<dt id="O-file">O=&lt;file&gt;</dt>
<dd>

<p>Append the debugger output stream to the specified file.</p>

</dd>
<dt id="t">t</dt>
<dd>

<p>Enable function control flow tracing., i.e. print enter and leave info for functions.</p>

</dd>
</dl>

<h2 id="Debugging-output">Debugging output</h2>

<p>Any program where debugging, tracing or profiling is enabled, will send debugging output in a standard format to the output destination (which may have been specified in the dbug control string).</p>

<p>This output can be formatted by the Perl script <code>dbugrpt</code>. There are several formatting options available for this program.</p>

<p>This is the output of the <i>DBUG</i> library.</p>

<ul>

<li><p>Output of DBUG_INIT, DBUG_INIT_CTX, dbug_init and dbug_init_ctx.</p>

<p>A line containing &#39;DBUG&#39;, the UID (unique id) of dbug context, date (in GMT YYYYMMDDhhmmss format), a sequence number, &#39;I&#39;, major version, minor version, teeny version, name, address of dbug context, process id and the flags will be printed. Flags is a bit masked integer where tracing equals 1 (see <code>t</code>), debugging equals 2 (see <code>d</code>) and profiling equals 4 (see <code>g</code>).</p>

<p>This is the line printed:</p>

<p>DBUG#&lt;dbug uid&gt;#&lt;date&gt;#&lt;seq&gt;#I#&lt;major version&gt;.&lt;minor version&gt;.&lt;teeny version&gt;#&lt;name&gt;#&lt;dbug context&gt;#&lt;process id&gt;#&lt;flags&gt;</p>

</li>
<li><p>Output of DBUG_DONE, DBUG_DONE_CTX, dbug_done and dbug_done_ctx.</p>

<p>A line containing &#39;DBUG&#39;, the UID of the dbug context, date (in GMT YYYYMMDDhhmmss format), a sequence number, &#39;D&#39;, the maximum number of functions on the stack and the stack usage will be printed.</p>

<p>This is the line printed:</p>

<p>DBUG#&lt;dbug uid&gt;#&lt;date&gt;#&lt;seq&gt;#D#&lt;maximum number of functions on the stack&gt;#&lt;stack usage&gt;</p>

</li>
<li><p>Output of DBUG_ENTER, DBUG_ENTER_CTX, dbug_enter and dbug_enter_ctx.</p>

<p>A line consisting of &#39;DBUG&#39;, the UID of dbug context, date (in GMT YYYYMMDDhhmmss format), a sequence number, &#39;E&#39;, file, function, line, level and the (wall) time will be printed.</p>

<p>The (wall) time is printed as a double using the &quot;printf&quot; library function format &quot;%015.*f&quot; where the start (&#39;*&#39;) is for the variable for the number of digits after the radix character (.). The number of digits depends on the clock library function resolution. The clock library function is one of the library functions &quot;clock_gettime&quot;, &quot;gettimeofday&quot;, &quot;getrusage&quot;, &quot;ftime&quot; or &quot;clock&quot;.</p>

<p>If profiling is off, the (wall) time equals -1.</p>

<p>This is the line printed:</p>

<p>DBUG#&lt;dbug uid&gt;#&lt;date&gt;#&lt;seq&gt;#E#&lt;file&gt;#&lt;function&gt;#&lt;line&gt;#&lt;level&gt;#&lt;time&gt;</p>

</li>
<li><p>Output of DBUG_LEAVE, DBUG_LEAVE_CTX, dbug_leave and dbug_leave_ctx.</p>

<p>A line consisting of &#39;DBUG&#39;, the UID of dbug context, date (in GMT YYYYMMDDhhmmss format), a sequence number, &#39;L&#39;, file, function, line, level and (wall) time will be printed.</p>

<p>See for an explanation of (wall) time above.</p>

<p>This is the line printed:</p>

<p>DBUG#&lt;dbug uid&gt;#&lt;date&gt;#&lt;seq&gt;#L#&lt;file&gt;#&lt;function&gt;#&lt;line&gt;#&lt;level&gt;#&lt;time&gt;</p>

</li>
<li><p>Output of DBUG_PRINT, DBUG_PRINT_CTX, dbug_print and dbug_print_ctx.</p>

<p>A line consisting of &#39;DBUG&#39;, the UID of dbug context, date (in GMT YYYYMMDDhhmmss format), a sequence number, &#39;P&#39;, file, function, line, level, break point and user supplied parameters is printed. File and function may be empty when there is no active function context.</p>

<p>DBUG#&lt;dbug uid&gt;#&lt;date&gt;#&lt;seq&gt;#P#&lt;file&gt;#&lt;function&gt;#&lt;line&gt;#&lt;level&gt;#&lt;break point&gt;#&lt;user supplied parameters&gt;</p>

</li>
<li><p>Output of errors.</p>

<p>Errors are printed to stderr in the following format:</p>

<p>DBUG#&lt;dbug context&gt;#ERROR: &lt;function name&gt;: &lt;description&gt;</p>

<p>Status values are defined in &lt;errno.h&gt;.</p>

</li>
</ul>

<h2 id="Debug-reporting-tool">Debug reporting tool</h2>

<p>After a program has sent its output to a file (or whatever), the debug report tool can be used to create a user friendly output in various ways. The options are supplied to <code>dbugrpt</code> in a standard (Unix) way. This program uses standard input to create the report. It is possible to store several runs of a program in an output file and input this file to the debug reporting tool.</p>

<h2 id="Debug-report-options">Debug report options</h2>

<p>This section summarizes the currently available report options and the flag characters which enable or disable them.</p>

<dl>

<dt id="d-break-points">d[&lt;break points&gt;]</dt>
<dd>

<p>Enable output from DBUG_PRINT macros which have a break point which is in the list of specified break points (separated by comma&#39;s). A null list means all break points are enabled.</p>

</dd>
<dt id="D">D</dt>
<dd>

<p>Emulate a done() call (if missing) at the end of each debugging context in order to print totals.</p>

</dd>
<dt id="F">F</dt>
<dd>

<p>Mark each debugger output line with the name of the source file containing the macro causing the output.</p>

</dd>
<dt id="h">h</dt>
<dd>

<p>Print help.</p>

</dd>
<dt id="i">i</dt>
<dd>

<p>Identify the process emitting each line of debug or trace output with the process id for that process.</p>

</dd>
<dt id="L">L</dt>
<dd>

<p>Mark each debugger output line with the source file line number of the macro causing the output.</p>

</dd>
<dt id="n">n</dt>
<dd>

<p>Mark each debugger output line with the current function nesting depth.</p>

</dd>
<dt id="N">N</dt>
<dd>

<p>Sequentially number each debugger output line starting at 1. This is useful for reference purposes when debugger output is interspersed with program output.</p>

</dd>
<dt id="P">P</dt>
<dd>

<p>Mark each debugger output line with the name of the debugging context as supplied to <code>DBUG_INIT</code>.</p>

</dd>
<dt id="r-resolution">r[&lt;resolution&gt;]</dt>
<dd>

<p>The time resolution. A value of 1000 (default) means that time is printed in milliseconds.</p>

</dd>
<dt id="t-functions">t[&lt;functions&gt;]</dt>
<dd>

<p>Limit debugger and profiling actions to the specified list of comma separated functions. A null list of functions implies that all functions are selected.</p>

</dd>
<dt id="T">T</dt>
<dd>

<p>Print date/time of each output line.</p>

</dd>
<dt id="v">v</dt>
<dd>

<p>Print the debug reporting tool version.</p>

</dd>
</dl>

<h1 id="EXAMPLES">EXAMPLES</h1>

<p>We will start off learning about the capabilities of the <i>dbug</i> package by using a simple minded program which computes the factorial of a number. In order to better demonstrate the function trace mechanism, this program is implemented recursively.</p>

<h2 id="Main-function-for-factorial-program">Main function for factorial program</h2>

<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &quot;dbug.h&quot;

  extern int factorial (int value);

  int main (int argc, char *argv[])
  {
    int result, ix;
    char *options = &quot;&quot;;

    for (ix = 1; ix &lt; argc &amp;&amp; argv[ix][0] == &#39;-&#39;; ix++) 
      {
        switch (argv[ix][1]) 
    {
    case &#39;#&#39;:
      options = &amp;(argv[ix][2]);
      break;
    }
      }

    DBUG_INIT( options, &quot;factorial&quot; );
    {
      DBUG_ENTER(&quot;main&quot;);
      for (; ix &lt; argc; ix++) 
        {
    DBUG_PRINT(&quot;args&quot;, (&quot;argv[%d] = %s&quot;, ix, argv[ix]));
    result = factorial (atoi (argv[ix]));
    printf (&quot;%d\n&quot;, result);
    fflush( stdout );
        }
      DBUG_LEAVE();
    }
    DBUG_DONE();

    return (0);
  }

  Figure 4
  Factorial Program Mainline</code></pre>

<p>The <b>main</b> function is responsible for processing any command line option arguments and then computing and printing the factorial of each non-option argument.</p>

<p>First of all, notice that all of the debugger functions are implemented via preprocessor macros. This does not detract from the readability of the code and makes disabling all debug compilation trivial (a single preprocessor symbol, <code>DBUG_OFF</code>, forces the macro expansions to be null).</p>

<p>Also notice the inclusion of the header file <b>dbug.h</b> from the local header file directory. (The version included here is the test version in the dbug source distribution directory). This file contains all the definitions for the debugger macros, which all have the form <b>DBUG_XX...XX</b>.</p>

<p>The <code>DBUG_INIT</code> macro sets up a debugging context based on the control string passed as its argument. The <code>DBUG_ENTER</code> macro informs that debugger that we have entered the function named <b>main</b>. It must be the very first &quot;executable&quot; line in a function, after all declarations and before any other executable line. The <code>DBUG_PRINT</code> macro is used to print the values of each argument for which a factorial is to be computed. The <code>DBUG_LEAVE</code> macro tells the debugger that the end of the current function has been reached and returns a value to the calling function. All of these macros will be fully explained in subsequent sections.</p>

<p>To use the debugger, the factorial program is invoked with a command line of the form:</p>

<pre><code>  factorial -#d,t 1 2 3 | perl -S dbugrpt</code></pre>

<p>The <b>main</b> function recognizes the &quot;-#d,t&quot; string as a debugger control string, and passes the debugger arguments (&quot;d,t&quot;) to the <i>dbug</i> run-time support routines via the <code>DBUG_INIT</code> macro. This particular string enables output from the <code>DBUG_PRINT</code> macro with the &#39;d&#39; flag and enables function tracing with the &#39;t&#39; flag. The factorial function is then called three times, with the arguments &quot;1&quot;, &quot;2&quot;, and &quot;3&quot;.</p>

<p>Note that the DBUG_PRINT takes exactly <b>one</b> arguments enclosed in parentheses.</p>

<p>Debug control strings consist of a header, the &quot;-#&quot;, followed by a comma (or semi-colon) separated list of debugger options.</p>

<p>Each debugger argument is a single character flag followed by an optional equal sign and an argument specific to the given flag.</p>

<p>Some examples are:</p>

<pre><code>  -#d,t,o
  -#d,o=dbug.log</code></pre>

<p>The definition of the factorial function, symbolized as &quot;N!&quot;, is given by:</p>

<pre><code>  N! = N * N-1 * ... 2 * 1</code></pre>

<h2 id="Factorial-function">Factorial function</h2>

<p>Figure 5 is the factorial function which implements this algorithm recursively. Note that this is not necessarily the best way to do factorials and error conditions are ignored completely.</p>

<pre><code>  #include &lt;stdio.h&gt;
  #include &quot;dbug.h&quot;

  int factorial(int value)
  {
    DBUG_ENTER(&quot;factorial&quot;);
    DBUG_PRINT(&quot;find&quot;, (&quot;find %d factorial&quot;, value));
    if (value &gt; 1) {
      value *= factorial (value - 1);
    }
    DBUG_PRINT(&quot;result&quot;, (&quot;result is %d&quot;, value));
    DBUG_LEAVE();
    return (value);
  }

  Figure 5
  Factorial Function</code></pre>

<p>One advantage (some may not consider it so) to using the <i>dbug</i> package is that it strongly encourages fully structured coding with only one entry and one exit point in each function. Multiple exit points, such as early returns to escape a loop, may be used, but each such point requires the use of an appropriate <code>DBUG_LEAVE</code> macro.</p>

<p>To build the factorial program on a <b>UNIX</b> system, compile and link with the command:</p>

<pre><code>  cc -o factorial main.c factorial.c -ldbug</code></pre>

<p>The &quot;-ldbug&quot; argument tells the loader to link in the run-time support modules for the <i>dbug</i> package.</p>

<h2 id="No-debugging-and-or-tracing">No debugging and/or tracing</h2>

<p>Executing the factorial program with a command of the form:</p>

<pre><code>  factorial 1 2 3 4 5</code></pre>

<p>generates the output shown in figure 6.</p>

<pre><code>  1
  2
  6
  24
  120
  
  Figure 6
  factorial 1 2 3 4 5</code></pre>

<h2 id="Function-level-tracing">Function level tracing</h2>

<p>Function level tracing is enabled by passing the debugger the &#39;t&#39; flag in the debug control string. Figure 7 is the output resulting from the command &quot;factorial -#t 3 2 | perl -S dbugrpt&quot;.</p>

<pre><code>  &gt;main
  |   &gt;factorial
  |   |   &gt;factorial
  |   |   |   &gt;factorial
  |   |   |   &lt;factorial
  |   |   &lt;factorial
  |   &lt;factorial
  6
  |   &gt;factorial
  |   |   &gt;factorial
  |   |   &lt;factorial
  |   &lt;factorial
  2
  &lt;main
  
  Figure 7
  factorial -#t 3 2 | perl -S dbugrpt</code></pre>

<p>Each entry to or return from a function is indicated by &#39;&gt;&#39; for the entry point and &#39;&lt;&#39; for the exit point, connected by vertical bars to allow matching points to be easily found when separated by large distances.</p>

<p>This trace output indicates that there was an initial call to factorial from main (to compute 2!), followed by a single recursive call to factorial to compute 1!. The main program then output the result for 2! and called the factorial function again with the second argument, 3. Factorial called itself recursively to compute 2! and 1!, then returned control to main, which output the value for 3! and exited.</p>

<p>The mechanism used to produce &quot;printf&quot; style output is the <code>DBUG_PRINT</code> macro.</p>

<p>To allow selection of output from specific macros, one of the arguments to every <code>DBUG_PRINT</code> macro is a <i>dbug</i> break point.</p>

<p>When this break point appears in the argument list of the &#39;d&#39; flag in a debug report option, as in &quot;-d &lt;break point1&gt;,&lt;break point2&gt;,...&quot;, output from the corresponding macro is enabled. The default when there is no &#39;d&#39; flag in the control string is to enable output from all <code>DBUG_PRINT</code> macros.</p>

<p>Typically, a program will be run once, with no break points specified, to determine what break points are significant for the current problem (the break points are printed in the macro output line). Then the program will be run again, with the desired break points, to examine only specific areas of interest.</p>

<p>Another argument to a <code>DBUG_PRINT</code> macro is a standard printf style format string and one or more arguments to print, all enclosed in parenthesis so that they collectively become a single macro argument. This is how variable numbers of printf arguments are supported. Also note that no explicit newline is required at the end of the format string. As a matter of style, two or three small <code>DBUG_PRINT</code> macros are preferable to a single macro with a huge format string.</p>

<h2 id="Function-level-tracing-and-debugging">Function level tracing and debugging</h2>

<p>Figure 8 shows the output for default tracing and debug.</p>

<pre><code>  &gt;main
  |   args: argv[2] = 3
  |   &gt;factorial
  |   |   find: find 3 factorial
  |   |   &gt;factorial
  |   |   |   find: find 2 factorial
  |   |   |   &gt;factorial
  |   |   |   |   find: find 1 factorial
  |   |   |   |   result: result is 1
  |   |   |   &lt;factorial
  |   |   |   result: result is 2
  |   |   &lt;factorial
  |   |   result: result is 6
  |   &lt;factorial
  6
  &lt;main
  
  Figure 8
  factorial -#d,t 3 | perl -S dbugrpt</code></pre>

<p>The output from the <code>DBUG_PRINT</code> macro is indented to match the trace output for the function in which the macro occurs. When debugging is enabled, but not trace, the output starts at the left margin, without indentation.</p>

<h2 id="Debugging-a-break-point">Debugging a break point</h2>

<p>To demonstrate selection of specific macros for output, figure 9 shows the result when the report program is invoked with the debug report option &quot;-d result&quot;.</p>

<pre><code>  factorial: result: result is 1
  factorial: result: result is 2
  factorial: result: result is 6
  factorial: result: result is 24
  24
  
  Figure 9
  factorial -#d 4 | perl -S dbugrpt -d result</code></pre>

<h2 id="Debugging-a-function">Debugging a function</h2>

<p>It is sometimes desirable to restrict debugging and trace actions to a specific function or list of functions.</p>

<p>This is accomplished with the &#39;f&#39; debug report option. Figure 10 is the output of the factorial program when run with the debug control string &quot;-#d&quot; and the report options &quot;-t factorial -FL&quot;. The &#39;F&#39; flag enables printing of the source file name and the &#39;L&#39; flag enables printing of the source file line number.</p>

<pre><code>  factorial.c: 7: factorial: find: find 3 factorial
  factorial.c: 7: factorial: find: find 2 factorial
  factorial.c: 7: factorial: find: find 1 factorial
  factorial.c: 11: factorial: result: result is 1
  factorial.c: 11: factorial: result: result is 2
  factorial.c: 11: factorial: result: result is 6
  6
  
  Figure 10
  factorial -#d 3 | perl -S dbugrpt -t factorial -FL</code></pre>

<p>The output in figure 10 shows that the &quot;find&quot; macro is in file &quot;factorial.c&quot; at source line 7 and the &quot;result&quot; macro is in the same file at source line 11.</p>

<h2 id="Profiling-a-program">Profiling a program</h2>

<p>It is sometimes desirable to profile your program. The option &#39;g&#39; provides support for profiling. The debug reporting tool is able to print a profile report for each debugging context encountered as well as a total. Besides displaying timing results, also stack usage is printed. The stack usage is only determined for functions which have a dbug_enter/dbug_leave pair. Figure 11 is the output of the factorial program for determining the factorial of 3 when run with the debug control string &quot;-#t,D=1000,g&quot;.</p>

<pre><code>  &gt;main
  |   &gt;factorial
  |   |   &gt;factorial
  |   |   |   &gt;factorial
  |   |   |   &lt;factorial
  |   |   &lt;factorial
  |   &lt;factorial
  6
  &lt;main

  -------------------------------------------------------------------------------
  Profile of execution for debug context &#39;factorial&#39;
  Stack usage: 40 bytes
  Execution times are in seconds

         Calls           Time
         -----           ----
  function                 # calls % calls        time % time   time/call  weight
  ======================== ======= ======= =========== ====== =========== =======
  factorial                      3   75.00       5.000  71.74       1.667    5380
  main                           1   25.00       1.970  28.26       1.970     706
         ======= ======= =========== ======                    
  Totals                         4  100.00       6.970 100.00
  -------------------------------------------------------------------------------


  -------------------------------------------------------------------------------
  Profile of execution for debug context &#39;total&#39;
  Stack usage: 0 bytes
  Execution times are in seconds

         Calls           Time
         -----           ----
  function                 # calls % calls        time % time   time/call  weight
  ======================== ======= ======= =========== ====== =========== =======
  factorial                      3   75.00       5.000  71.74       1.667    5380
  main                           1   25.00       1.970  28.26       1.970     706
         ======= ======= =========== ======                    
  Totals                         4  100.00       6.970 100.00
  -------------------------------------------------------------------------------

  Figure 11
  factorial -#t,D=1000,g 3 | perl -S dbugrpt</code></pre>

<p>As you can see, it&#39;s quite self-evident. The &#39;weight&#39; column is a metric obtained by multiplying the percentage of the calls and the percentage of the time. Functions with higher &#39;weight&#39; benefit the most from being sped up.</p>

<h1 id="NOTES">NOTES</h1>

<h2 id="Tips">Tips</h2>

<p>One of the most useful capabilities of the <i>dbug</i> package is to compare the executions of a given program in two different environments. This is typically done by executing the program in the environment where it behaves properly and saving the debugger output in a reference file. The program is then run with identical inputs in the environment where it misbehaves and the output is again captured in a reference file. The two reference files can then be differentially compared to determine exactly where execution of the two processes diverges.</p>

<p>A related usage is regression testing where the execution of a current version is compared against executions of previous versions. This is most useful when there are only minor changes.</p>

<h2 id="Compatibility">Compatibility</h2>

<p>The original <i>DBUG</i> library written by Fred Fish differs from the current library. I tried to keep it code compatible, but I have made some minor changes. Keep in mind that the original library has been written in the 80&#39;s.</p>

<p>These are the differences:</p>

<dl>

<dt id="ANSI-C">ANSI C</dt>
<dd>

<p>I have converted the source to ANSI C since this is the standard now.</p>

</dd>
<dt id="POSIX-threads">POSIX threads</dt>
<dd>

<p>I have modified the library to make use of POSIX threads. All macro&#39;s (and functions) have now reentrant functions with the extension _ctx. The standard functions (without _ctx) are also thread-safe because they use thread-specific data (pthread_getspecific).</p>

</dd>
<dt id="Delay">Delay</dt>
<dd>

<p>The delay argument in the debug control string is now specified in milliseconds, instead of tenths of seconds.</p>

</dd>
<dt id="Debug-control-string1">Debug control string</dt>
<dd>

<p>The old format for the debug control string used options separated by colons and modifiers separated by comma&#39;s. Since the colon might be part of a (DOS) file name, I had to change the option separator into the comma. The modifier separator has become the equal sign. So -#d:D,2 has become -#d,D=200. I also separated content and formatting of the debugging output, hence several options are now obsolete in the debug control string and have been moved to the options of the debug reporting tool.</p>

</dd>
<dt id="Debug-reporting-tool1">Debug reporting tool</dt>
<dd>

<p>There is now a Perl debug reporting tool which formats the debugging output in a user friendly way.</p>

</dd>
<dt id="DEBUG_LEAVE">DEBUG_LEAVE</dt>
<dd>

<p>Needs an empty parameter list now.</p>

</dd>
<dt id="DBUG_2">DBUG_2</dt>
<dd>

<p>This macro is obsolete now. Use DBUG_PRINT instead.</p>

</dd>
<dt id="DBUG_3">DBUG_3</dt>
<dd>

<p>This macro is obsolete now. Use DBUG_PRINT instead.</p>

</dd>
<dt id="DBUG_4">DBUG_4</dt>
<dd>

<p>This macro is obsolete now. Use DBUG_PRINT instead.</p>

</dd>
<dt id="DBUG_5">DBUG_5</dt>
<dd>

<p>This macro is obsolete now. Use DBUG_PRINT instead.</p>

</dd>
<dt id="DBUG_SETJMP">DBUG_SETJMP</dt>
<dd>

<p>This macro is obsolete now. I think it is better not to use setjmp and longjmp in programs.</p>

</dd>
<dt id="DBUG_LONGJMP">DBUG_LONGJMP</dt>
<dd>

<p>This macro is obsolete now. I think it is better not to use setjmp and longjmp in programs.</p>

</dd>
</dl>

<h1 id="CAVEATS">CAVEATS</h1>

<p>he <i>dbug</i> package works best with programs which have &quot;line oriented&quot; output, such as text processors, general purpose utilities, etc. It can be interfaced with screen oriented programs such as visual editors by redefining the appropriate macros to call special functions for displaying the debugger results. Of course, this caveat is not applicable if the debugger output is simply dumped into a file for post-execution examination.</p>

<p>This library uses standard memory allocation routines such as <b>malloc</b> and <b>realloc</b>. Programs using other memory allocation routines might suffer from memory holes.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p><i>Fred</i> <i>Fish</i> - Developer of first version.</p>

<p><i>Gert-Jan</i> <i>Paulissen</i> - Redesign for enabling multi threaded support.</p>

<h1 id="HISTORY">HISTORY</h1>

<p>Originally, this library has been written by Fred Fish in the 80&#39;s. In 1999 Gert-Jan Paulissen modified the source to make it portable using ANSI C and an imake configuration. The documentation is now in Perl&#39;s pod format.</p>


</body>

</html>


